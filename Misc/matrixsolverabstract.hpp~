/*
Header file for QuantumMechanics::MatrixSolverAbstract:

This file solves a list of one or more matrices stored in a c-style array, stl-style vector,
or a return from a function(int). When not using vector (or a single matrix) the

---
Copyright (C) 2014, Søren Schou Gregersen <sorge@nanotech.dtu.dk>
*/
#ifndef _MATRIXSOLVERABSTRACT_H_
#define _MATRIXSOLVERABSTRACT_H_

#include "../Math/Dense"

namespace QuantumMechanics {

template <typename IN, typename OUT, typename COMPUTEENUM>
class MatrixSolverAbstract {
public:
	typedef IN InputMatrixType;
	typedef OUT OutputMatrixType;
	typedef COMPUTEENUM ComputeEnumType;

private:
	const size_t matrix_size;
	const Math::Ref<const InputMatrixType> matrix;
	OutputMatrixType solution_matrix;

	ArrayXi block_sizes;
	ArrayXi block_offsets;

	static const InputMatrixType empty_matrix;

public:
	MatrixSolverAbstract() :
		matrix_size(0),
		matrix(empty_matrix),
		block_sizes(ArrayXi::Constant(1,0)),
		block_offsets(ArrayXi::Constant(1,0))
	{ }

	MatrixSolverAbstract(const Math::Ref<const InputMatrixType> &M) :
		matrix_size((M.rows() == M.cols() && M.rows() > 0) ? M.rows() : 0),
		matrix(M),
		block_sizes(ArrayXi::Constant(1,(M.rows() == M.cols() && M.rows() > 0) ? M.rows() : 0)),
		block_offsets(ArrayXi::Constant(1,0))
	{ }

	MatrixSolverAbstract(const Math::Ref<const InputMatrixType> &M, const size_t &size) :
		matrix_size((M.rows() >= size && M.cols() >= size && size > 0) ? size : 0),
		matrix(M),
		block_sizes(ArrayXi::Constant(1,(M.rows() >= size && M.cols() >= size && size > 0) ? size : 0)),
		block_offsets(ArrayXi::Constant(1,0))
	{ }

	virtual ~MatrixSolverAbstract() { }

	virtual void setBlockSizes(const ArrayXi &sizes) {
		if (sizes.sum() > matrix_size)
		{
			block_sizes = ArrayXi::Constant(1,matrix_size);
			block_offsets = ArrayXi::Constant(1,0);
			return;
		}

		block_sizes = sizes;
		const long block_count = block_sizes.size();
		block_offsets = ArrayXi(block_count);
		block_offsets[0] = 0;
		// A cumulative sum (first,last,destination_start).
		std::partial_sum(&block_sizes[0], &block_sizes[block_count - 1], &block_offsets[1]);
	}

	virtual inline bool blockMatrix() const {
		return (block_sizes.size() > 1);
	}

	virtual inline void compute(const ComputeEnumType &action) = 0;

	inline const const Math::Ref<const InputMatrixType> &input() const {
		return matrix;
	}

	inline const OutputMatrixType &solution() const {
		return solution_matrix;
	}

	inline OutputMatrixType &solution() {
		return solution_matrix;
	}

protected:
	inline const ArrayXi &blockOffsets() const {
		return block_offsets;
	}

	inline const ArrayXi &blockSizes() const {
		return block_sizes;
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> block(const LOCAL &M, long i, long j) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(blockOffsets()[i], blockOffsets()[j], blockSizes()[i], blockSizes()[j]);
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> blockRange(const LOCAL &M, long i, long j, const long &n, const long &m) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(
			blockOffsets()[i],
			blockOffsets()[j],
			((n > 0) ? blockSizes().segment(i, n).sum() : blockSizes().segment(i + n, -n).sum()),
			((m > 0) ? blockSizes().segment(j, m).sum() : blockSizes().segment(j + m, -n).sum())
			);
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> blockRow(const LOCAL &M, long i) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		return M.block(blockOffsets()[i], 0, blockSizes()[i], M.cols());
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> blockColumn(const LOCAL &M, long j) const {
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(0, blockOffsets()[j], M.rows(), blockSizes()[j]);
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> blockRowRange(const LOCAL &M, long i, const long &n) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		return M.block(
			blockOffsets()[i],
			0,
			((n > 0) ? blockSizes().segment(i, n).sum() : blockSizes().segment(i + n, -n).sum()),
			M.cols()
			);
	}

	template <typename LOCAL>
	inline const Math::Block<const LOCAL> blockColumnRange(const LOCAL &M, long j, const long &m) const {
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(
			0,
			blockOffsets()[j],
			M.rows(),
			((m > 0) ? blockSizes().segment(j, m).sum() : blockSizes().segment(j + m, -n).sum())
			);
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> block(LOCAL &M, long i, long j) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(blockOffsets()[i], blockOffsets()[j], blockSizes()[i], blockSizes()[j]);
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> blockRange(LOCAL &M, long i, long j, const long &n, const long &m) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(
			blockOffsets()[i],
			blockOffsets()[j],
			((n > 0) ? blockSizes().segment(i, n).sum() : blockSizes().segment(i + n, -n).sum()),
			((m > 0) ? blockSizes().segment(j, m).sum() : blockSizes().segment(j + m, -n).sum())
			);
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> blockRow(LOCAL &M, long i) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		return M.block(blockOffsets()[i], 0, blockSizes()[i], M.cols());
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> blockColumn(LOCAL &M, long j) const {
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(0, blockOffsets()[j], M.rows(), blockSizes()[j]);
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> blockRowRange(LOCAL &M, long i, const long &n) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		return M.block(
			blockOffsets()[i],
			0,
			((n > 0) ? blockSizes().segment(i, n).sum() : blockSizes().segment(i + n, -n).sum()),
			M.cols()
			);
	}

	template <typename LOCAL>
	inline Math::Block<LOCAL> blockColumnRange(LOCAL &M, long j, const long &m) const {
		j = (j >= 0) ? j : block_sizes.size() + j;
		return M.block(
			0,
			blockOffsets()[j],
			M.rows(),
			((m > 0) ? blockSizes().segment(j, m).sum() : blockSizes().segment(j + m, -n).sum())
			);
	}

	template <typename LOCAL>
	inline LOCAL zeroBlock(long i, long j) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return LOCAL::Zero(blockSizes()(i), blockSizes()(j));
	}

	template <typename LOCAL>
	inline LOCAL zeroBlockRange(long i, long j, const long &n, const long &m) const {
		i = (i >= 0) ? i : block_sizes.size() + i;
		j = (j >= 0) ? j : block_sizes.size() + j;
		return LOCAL::Zero(
			((n > 0) ? blockSizes().segment(i, n).sum() : blockSizes().segment(i + n, -n).sum()),
			((m > 0) ? blockSizes().segment(j, m).sum() : blockSizes().segment(j + m, -n).sum())
			);
	}

	inline long blockCount() const {
		return block_sizes.size();
	}

};

template <typename  IN, typename  OUT, typename COMPUTEENUM>
const MatrixSolverAbstract<IN,OUT,COMPUTEENUM>::InputMatrixType MatrixSolverAbstract<IN,OUT,COMPUTEENUM>::empty_matrix;

};

#endif //namespace _MATRIXSOLVERABSTRACT_H_
